% IMPORTACTIGRAPHGT3X
% Imports raw data from ActiGraph GT3X files (ActiGraph, Pensacola, USA).
% It is not recommended to call this function directly, but rather use the
% function 'cic_newdataset'.
%
% Usage:
%   >> ACT = importactigraphgt3x(ACT, cfg);
%
% Inputs:
%   'ACT' - [struct] empty standardized ACT structure generated by
%           'cic_emptydataset'
%   'cfg' - [struct] configuration settings with the fields:
%           - 'FullFilePath' [char] full path to the GT3X file
%
% Outputs:
%   'ACT' - [struct] empty standardized ACT structure generated by
%           'cic_emptydataset'
%
% See also CIC_NEWDATASET, CIC_EMPTYDATASET.

% Authors:
%   Simon Kamronn, Technical University of Denmark, Lyngby Denmark
%   Rick Wassing, Woolcock Institute of Medical Research, Sydney, Australia
%
% History:
%   Created 7 years ago, Simon Kamronn
%   Edited 2023-08-24, Rick Wassing, adaptations to fit Cicada code formatting

% Cicada (C) 2023 by Rick Wassing is licensed under
% Attribution-NonCommercial-ShareAlike 4.0 International
% This license requires that reusers give credit to the creator. It allows
% reusers to distribute, remix, adapt, and build upon the material in any
% medium or format, for noncommercial purposes only. If others modify or
% adapt the material, they must license the modified material under
% identical terms.

function ACT = importactigraphgt3x(ACT, cfg)
% =========================================================================
% Check that the input file exists
if exist(cfg.FullFilePath, 'file') == 0
    % file did not open, return empty dataset
    error('Could not import ''%s'', file not found.', cfg.FullFilePath)
end
% =========================================================================
% UNZIP
% -------------------------------------------------------------------------
% Create temp directory to unpack zip file
tmpdir = [fileparts(which('cicada.mlapp')), filesep, 'temp'];
if exist(tmpdir, 'dir') == 0
    [status, msg] = mkdir(tmpdir);
    if status == 0
        % could not create temp directory
        error('Could not create temporary directory. %s.', msg)
    end
end
% -------------------------------------------------------------------------
% Unzip the file
filenames = unzip(cfg.FullFilePath, tmpdir);
% =========================================================================
% Check that the files 'info.txt' and 'log.bin' exist
if sum(contains(filenames, 'info.txt') | contains(filenames, 'log.bin')) ~= 2
    % The expected files were not contained in the zip file
    error('Could not import ''%s'', the file did not contain header information and data.', cfg.FullFilePath)
end
% =========================================================================
% Read info
infofile = filenames{contains(filenames, 'info.txt')};
[fid, msg] = fopen(infofile, 'r');
% -------------------------------------------------------------------------
% Check that the file could be read
if fid <= 0
    error('Could not import ''%s'', could not read header information file. %s', cfg.FullFilePath, msg)
end
% -------------------------------------------------------------------------
% Scan the text from the text-file and parse using regular expression
pattern = '(?<field>[^:]+):\s+(?<values>[^\r\n]+)\s*';
txt = fscanf(fid, '%c');
result = regexp(txt, pattern, 'names');
% -------------------------------------------------------------------------
% Save the header information to a structure
header = struct();
for i = 1:numel(result)
    fieldName = strrep(result(i).field, ' ', '_');
    header.(fieldName) = result(i).values;
end
% -------------------------------------------------------------------------
% Close the file
fclose(fid);
% Check that the sampling rate is adequate
if str2double(header.Sample_Rate) < 10
    error('Could not import ''%s'', sampling rate must be at least 10 Hz', cfg.FullFilePath)
end
% =========================================================================
% Read bin
binfile = filenames{contains(filenames, 'log.bin')};
[fid, msg] = fopen(binfile, 'r', 'b');
% -------------------------------------------------------------------------
% Check that the file could be read
if fid <= 0
    error('Could not import ''%s'', could not read data file. %s', cfg.FullFilePath, msg)
end
% -------------------------------------------------------------------------
% Some constants
recordCount = 0;
encodingEPS = 1/341;
precisionUBit12 = 'ubit12=>double';
precisionSShort = 'short=>double';
axesPerRecord = 3;
checksumSizeBytes = 1;
accelCodeUBit12 = 0;
accelCodeSShort = 26;
capacitiveSensorCode = 13; %#ok<NASGU>
parametersCode = 19; %#ok<NASGU>
eventCode = 3; %#ok<NASGU>
metadataCode = 6; %#ok<NASGU>
bitsPerByte = 8;
bitsPerAccelRecordUBit12 = 36;  % size in number of bits (12 bits per acceleration axis)
recordsPerByteUBit12 = bitsPerByte/bitsPerAccelRecordUBit12;
bitsPerAccelRecordSShort = 18;  % size in number of bits (1 bit per acceleration axis)
recordsPerByteSShort = bitsPerByte/bitsPerAccelRecordSShort;
timeStampSizeBytes = 4; %#ok<NASGU>
packetSize = struct();
% -------------------------------------------------------------------------
% Read the file to extract the number of records
while ~feof(fid)
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    % Read a line of data
    separator = fread(fid, 1, 'char', 'l'); %#ok<NASGU>
    typeid = fread(fid, 1,'char','l');
    timestamp = fread(fid, 1, 'ulong', 'l'); %#ok<NASGU>
    packetSizeBytes = fread(fid, 1, 'ushort', 'l');
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    % Break out of while loop if end of file is reached
    if feof(fid)
        break
    end
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    % Add to the counter of the number of records
    if typeid == accelCodeUBit12 || typeid == accelCodeSShort
        packetRecordCount = packetSizeBytes * recordsPerByteUBit12;
        if packetRecordCount > 1
            recordCount = recordCount + packetRecordCount;
        end
    end
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    % Skip ahead to next valid packet
    if packetSizeBytes ~= 0
        fseek(fid, packetSizeBytes+checksumSizeBytes, 0);
    end
end
% -------------------------------------------------------------------------
% Rewind the file and now read the data
frewind(fid);
cnt.accel1 = 1;
cnt.accel2 = 1;
bindata.accel1 = zeros(recordCount, axesPerRecord);
bindata.accel2 = zeros(recordCount, axesPerRecord);
timeStamp = zeros(recordCount, 1);
while ~feof(fid) && cnt.accel1 <= recordCount && cnt.accel2 <= recordCount
    cnt
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    % Read a line of data
    separator = fread(fid, 1, 'char', 'l'); %#ok<NASGU>
    typeid = fread(fid, 1, 'char','l');
    timestamp = fread(fid, 1, 'ulong', 'l');
    packetSizeBytes = [1, 256] * fread(fid, 2, 'uint8');
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    % Read the data if the type is triaxial acceleration
    if typeid == parametersCode
        tmplong = fread(fid, [1, packetSizeBytes]);
    elseif typeid == accelCodeUBit12
        % timeStamp(cnt) = timestamp;
        pSize.accel1 = packetSizeBytes * recordsPerByteUBit12;
        bindata.accel1(cnt.accel1:cnt.accel1+pSize.accel1-1, :) = fread(fid, [axesPerRecord, pSize.accel1], precisionUBit12)';
        cnt.accel1 = cnt.accel1 + pSize.accel1;
        checkSum = fread(fid, checksumSizeBytes, 'uint8'); %#ok<NASGU>
    elseif typeid == accelCodeSShort
        % timeStamp(cnt) = timestamp;
        pSize.accel2 = packetSizeBytes * recordsPerByteSShort;
        tmplong = fread(fid, [1, packetSizeBytes], precisionSShort)';
        tmpcol = reshape(tmplong, [3, 540/3]);
        



        bindata.accel2(cnt.accel2:cnt.accel2+pSize.accel2-1, :) = fread(fid, [axesPerRecord, pSize.accel2], precisionSShort)';
        cnt.accel2 = cnt.accel2 + pSize.accel2;
        checkSum = fread(fid, checksumSizeBytes, 'uint8'); %#ok<NASGU>
    else
        % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        % Skip ahead to next valid packet
        if ~feof(fid)
            fseek(fid, packetSizeBytes + checksumSizeBytes, 0);
        end
    end
end
% -------------------------------------------------------------------------
% remove temporary directory
[status, msg] = rmdir(tmpdir, 's'); % the 's' flag deletes a directory even if it's not empty
if status == 0
    % could not delete temp directory
    error('Could not delete temporary directory. %s.', msg)
end
% -------------------------------------------------------------------------
% Check that the record count match the expected number of records
cnt = cnt - 1;  % adjust for the 1 base offset matlab uses.
if recordCount~=cnt
    error('Could not import ''%s'', there is a mismatch between the expected number of records and the record count.', cfg.FullFilePath)
end
% -------------------------------------------------------------------------
% Transform data to floating points
axesFloatData = (-bitand(bindata, 2048) + bitand(bindata, 2047)) * encodingEPS;
% -------------------------------------------------------------------------
% Save header information
Info.accel.range = [str2double(header.Acceleration_Min), str2double(header.Acceleration_Max)];
Info.accel.resolution = range(Info.accel.range) / str2double(header.Acceleration_Scale);
Info.accel.unit = 'g';
ACT.info.modalities = {'accel'};
ACT.info.devices(1).name = 'actigraph';
ACT.info.devices(1).serial = header.Serial_Number;
if ~isempty(header.TimeZone) && length(header.TimeZone) > 5
    ACT.info.time_zone = ['+', header.TimeZone(1:5)];
else
    ACT.info.time_zone = 'unspecified';
end
ACT.info.institute = 'unspecified';
ACT.info.study = 'unspecified';
ACT.info.researcher = 'unspecified';
ACT.info.participant_id = header.Subject_Name;
ACT.info.location = lower(header.Limb);
ACT.info.sex = 'unspecified';
ACT.info.height = 'unspecified';
ACT.info.weight = 'unspecified';
ACT.info.handedness = 'unspecified';
ACT.info.dob = '1900-01-01';
% -------------------------------------------------------------------------
% Calibration
ACT.etc.cal.accel.actigraph.x_gain = 1;
ACT.etc.cal.accel.actigraph.y_gain = 1;
ACT.etc.cal.accel.actigraph.z_gain = 1;
ACT.etc.cal.accel.actigraph.x_offset = 0;
ACT.etc.cal.accel.actigraph.y_offset = 0;
ACT.etc.cal.accel.actigraph.z_offset = 0;
% -------------------------------------------------------------------------
% Save data
ACT.data(1).modality = 'accel';
ACT.data(1).device = 'actigraph';
ACT.data(1).label = 'accelerometer';
ACT.data(1).loc = ACT.info.location;
ACT.data(1).unit = 'g';
ACT.data(1).y = single(axesFloatData);
ACT.data(1).srate = str2double(header.Sample_Rate);
ACT.data(1).pnts = size(ACT.data(1).y, 1);
ACT.data(1).xmin = char(datetime(str2double(header.Start_Date), ...
    'ConvertFrom', 'epochtime', ...
    'Epoch', '0000-01-01', ...
    'TicksPerSecond', 10000000), 'uuuu-MM-dd''T''HH:mm:ss.SSS');
ACT.data(1).xmax = char(datetime(str2double(header.Stop_Date), ...
    'ConvertFrom', 'epochtime', ...
    'Epoch', '0000-01-01', ...
    'TicksPerSecond', 10000000), 'uuuu-MM-dd''T''HH:mm:ss.SSS');
ACT.data(1).resolution = Info.accel.resolution;
ACT.data(1).ymin = Info.accel.range(1);
ACT.data(1).ymax = Info.accel.range(2);
% ---------------------------------------------------------
% Check that all samples are accounted for
Times = gettimes(ACT.data(1));
if length(Times) ~= ACT.data(1).pnts
    error('Could not import ''%s'', there is a mismatch between the expected number of samples and the recorded samples.', cfg.FullFilePath)
end

end